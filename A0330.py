'''
병합정렬
- 재귀 용법을 활용한 정렬 알고리즘
1. 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
2. 각 부분 리스트를 재귀적으로 병합 정렬을 이용해 정렬한다.
3. 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.

-분할 정복(divide and conquer)방법
문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음,
결과를 모아서 원래의 문제를 해결하는 전략

ex) data=[1,8,3,2]
    1. len(data)//2
        [1,8] [3,2]
    2.[1],[8],[3],[2]
    3. 다시 정렬해서 합친다.
        [1,8] [2,3]
    4. 1<2=[1]
       8>2=[1,2]
       8>3=[1,2,3]
       8밖에 없으니=[1,2,3,8]


'''
# a=[31,20,22,30,35,23,25,32]
# h=len(a)//2
# a1=a[:h]
# a2=a[h:]
#
#
# # 쉽게 설명한 병합 정렬
#
# # 입력: 리스트 a
#
# # 출력: 정렬된 새 리스트
#
#
# def merge_sort(a):
#     n = len(a)
#
#     # 종료 조건: 정렬할 리스트의 자료 개수가 한 개 이하이면 정렬할 필요 없음
#
#     if n <= 1:
#         return a
#
#     # 그룹을 나누어 각각 병합 정렬을 호출하는 과정
#
#     mid = n // 2  # 중간을 기준으로 두 그룹으로 나눔
#
#     g1 = merge_sort(a[:mid])  # 재귀 호출로 첫 번째 그룹을 정렬
#
#     g2 = merge_sort(a[mid:])  # 재귀 호출로 두 번째 그룹을 정렬
#
#     # 두 그룹을 하나로 병합
#
#     result = []  # 두 그룹을 합쳐 만들 최종 결과
#
#     while g1 and g2:  # 두 그룹에 모두 자료가 남아 있는 동안 반복
#
#         if g1[0] < g2[0]:  # 두 그룹의 맨 앞 자료 값을 비교
#
#             # g1 값이 더 작으면 그 값을 빼내어 결과로 추가
#
#             result.append(g1.pop(0))
#
#         else:
#
#             # g2 값이 더 작으면 그 값을 빼내어 결과로 추가
#
#             result.append(g2.pop(0))
#
#     # 아직 남아 있는 자료들을 결과에 추가
#
#     # g1과 g2 중 이미 빈 것은 while을 바로 지나감
#
#     while g1:
#         result.append(g1.pop(0))
#
#     while g2:
#         result.append(g2.pop(0))
#
#     return result
#
#
# d = [6, 8, 3, 9, 10, 1, 2, 4, 7, 5]
#
# print(merge_sort(d))

'''
수 N개 a,b,c....n이 주어진다. A를 오름차순 정렬했을 때, 
앞에서부터 K번째 있는 수를 구하는 프로그램을 작성해라.
'''
# def N():
#     n=list(map(int,input("여러 숫자 : ").split()))
#     k=int(input("몇 번째 ?"))
#     n.sort()
#     return n[k-1]
#
# print(N())
'''
N개의 숫자가 입력으로 주어집니다.
N개의 수를 오름차순으로 정렬한 다음 N개의 수 중
한 개의 수인 M이 주어지면 이분검색으로 M이 정렬된 상태에서
몇 번째에 있는지 구하는 프로그램을 작성하세요(중복 x)

입력
첫 줄에 한 줄에 자연수 N(3<=N<=1000000)과 M이 주어집니다
두 번째 줄에 N개의 수가 공백을 사이에 두고 주어집니다.

출력
첫 줄에 정렬 후 M의 값이 위치 번호를 출력한다

입력
8 32
23 87 65 12 57 32 99 81
출력

'''
####################################################
# def F():
#     N,M=map(int,input("몇개?,무슨 숫자?").split())
#     li=list(map(int,input("list에 넣을 수 :").split()))
#     li.sort()
#     def sl():
#         for i in
#             a=len(li)//2
#             a1=a[:a]
#             a2=a[a:]

'''
퀵 정렬 ( quick sort )
- 기준점(pivot)을 정해서 기준점보다 작은 데이터는 왼쪽,
큰 데이터는 오른쪽으로 모으는 함수

- 각 왼쪽, 오른쪽은 재귀용법을 사용해 다시 동일 함수를
호출하여 위 작업을 반복

ex) 3 7 4 5 1 8 2
            p
    3 7 4   5   1 8 2
    3 2 4   5   1 8 7
    3 2 4   1   5 8 7
    ------------------- 한 바퀴
    => p를 기준으로 그룹이 나뉨
    3 2 4 1        5 8 7
    1 2 3 4        5 7 8
    
1. 피벗을 정한다. 
2. left < pivot
    right > pivot


'''
#
#
# # 쉽게 설명한 퀵 정렬
#
# # 입력: 리스트 a
#
# # 출력: 정렬된 새 리스트
#
#
# def quick_sort(a):
#     n = len(a)
#
#     # 종료 조건: 정렬할 리스트의 자료 개수가 한 개 이하이면 정렬할 필요가 없음
#
#     if n <= 1:
#         return a
#
#     # 기준 값을 정하고 기준에 맞춰 그룹을 나누는 과정
#
#     pivot = a[-1]  # 편의상 리스트의 마지막 값을 기준 값으로 정함
#
#     g1 = []  # 그룹 1: 기준 값보다 작은 값을 담을 리스트
#
#     g2 = []  # 그룹 2: 기준 값보다 큰 값을 담을 리스트
#
#     for i in range(0, n - 1):  # 마지막 값은 기준 값이므로 제외
#
#         if a[i] < pivot:  # 기준 값과 비교
#
#             g1.append(a[i])  # 작으면 g1에 추가
#
#         else:
#
#             g2.append(a[i])  # 크면 g2에 추가
#
#     # 각 그룹에 대해 재귀 호출로 퀵 정렬을 한 후
#
#     # 기준 값과 합쳐 하나의 리스트로 결괏값 반환
#
#     return quick_sort(g1) + [pivot] + quick_sort(g2)
#
#
# d = [6, 8, 3, 9, 10, 1, 2, 4, 7, 5]
#
# print(quick_sort(d))
# ###
# # 퀵 정렬
#
# # 입력: 리스트 a
#
# # 출력: 없음(입력으로 주어진 a가 정렬됨)
#
# # 리스트 a에서 어디부터(start) 어디까지(end)가 정렬 대상인지
#
# # 범위를 지정하여 정렬하는 재귀 호출 함수
#
# def quick_sort_sub(a, start, end):
#     # 종료 조건: 정렬 대상이 한 개 이하이면 정렬할 필요가 없음
#
#     if end - start <= 0:
#         return
#
#     # 기준 값을 정하고 기준 값에 맞춰 리스트 안에서 각 자료의 위치를 맞춤
#
#     # [기준 값보다 작은 값들, 기준 값, 기준 값보다 큰 값들]
#
#     pivot = a[end]  # 편의상 리스트의 마지막 값을 기준 값으로 정함
#
#     i = start
#
#     for j in range(start, end):
#
#         if a[j] <= pivot:
#             a[i], a[j] = a[j], a[i]
#
#             i += 1
#
#     a[i], a[end] = a[end], a[i]
#
#     # 재귀 호출 부분
#
#     quick_sort_sub(a, start, i - 1)  # 기준 값보다 작은 그룹을 재귀 호출로 다시 정렬
#
#     quick_sort_sub(a, i + 1, end)  # 기준 값보다 큰 그룹을 재귀 호출로 다시 정렬
#
#
# # 리스트 전체(0 ~ len(a) -1)를 대상으로 재귀 호출 함수 호출
#
# def quick_sort(a):
#     quick_sort_sub(a, 0, len(a) - 1)
#
#
# d = [6, 8, 3, 9, 10, 1, 2, 4, 7, 5]
#
# quick_sort(d)
#
# print(d)

'''
sorted( ) 함수는 인자로 리스트를 주면 
그 리스트를 정렬한 리스트를 새로 만들어 돌려줍니다.
반면에 sort( ) 함수는 새 리스트를 따로 만들지 않고 
정렬 대상이 되는 리스트 자체의 순서를 바꿔 줍니다.
'''
#########################################
'''
정렬되어있는 두 배열 A와 B가 주어진다. 두 배열을 합친 다음 정렬해서 출력하는
프로그램을 작성해라. 첫 줄은 리스트 A 크기 N, 리스트 B 크기 M
두 번째 줄은 리스트 A 내용, 세 번째 줄은 리스트 B의 내용
ex) 
 2 2 : N , M
 3 5 : A의 list
 2 9 : B의 list
 출력: 2 3 5 9
 2 1 
 4 7
 1
 출력: 1 4 7
'''
# def C():
#     N,M=map(int,input("A와 B의 크기 입력 :").split())
#     A=list(map(int,input("A의 리스트 :").split()))
#     B=list(map(int,input("B의 리스트 :").split()))
#     A.sort()
#     B.sort()
#     C=A+B
#     C.sort()
#     return C
#
# print(C())
#
# # 회문
# # 주어진 문장이 회문인지 아닌지 찾기(큐와 스택의 특징을 이용)
#
# # 입력: 문자열 s
#
# # 출력: 회문이면 True, 아니면 False
#
#
# def palindrome(s):
#     # 큐와 스택을 리스트로 정의
#
#     qu = []
#
#     st = []
#
#     # 1단계: 문자열의 알파벳 문자를 각각 큐와 스택에 넣음
#
#     for x in s:
#
#         # 해당 문자가 알파벳이면(공백, 숫자, 특수문자가 아니면)
#
#         # 큐와 스택에 각각 그 문자를 추가
#
#         if x.isalpha():
#             qu.append(x.lower())
#
#             st.append(x.lower())
#
#     # 2단계: 큐와 스택에 들어 있는 문자를 꺼내면서 비교
#
#     while qu:  # 큐에 문자가 남아 있는 동안 반복
#
#         if qu.pop(0) != st.pop():  # 큐와 스택에서 꺼낸 문자가 다르면 회문이 아님
#
#             return False
#
#     return True
#
#
# print(palindrome("Wow"))
#
# print(palindrome("Madam, I’m Adam."))
#
# print(palindrome("Madam, I am Adam."))




'''
N개의 문자열 데이터를 입력받아 앞에서 읽을 때나 뒤에서 읽을 때나 같은 경우(회문 문자열)
이면 YES를 출력하고 회문 문자열이 아니면 NO를 출력하는 프로그램을 작성한다.
단 회문을 검사할 때 대소문자를 구분하지 않습니다.
입력
첫 줄에 정수 N(1<=N<=20)이 주어지고, 그 다음 줄부터 N개의 단어가 입력된다.
각 단어의 길이는 100을 넘지 않는다.
출력
각 줄에 해당 문자열의 결과를 YES 또는 NO로 출력한다.
입력
3
level
moon
abcba
 
출력 
#1 YES
#2 NO
#3 YES
'''
# def re():
#     N=int(input("숫자를 입력헤으응 : "))
#
#     for i in range(N):
#         str=input("비교하고싶은 단어:").lower()
#         if str==str[::-1]:  #뒤집어도 같은지
#             print(f"'{str}' YES")
#         else:
#             print(f"'{str}' NO")
#
# re()


'''
영수는 현수에게 숫자 하나를 주고, 해당 숫자의 자릿수들 중 m개의 숫자를 제거하
여 가장 큰 수를 만들라고 했습니다. 현수를 도와주세요.(단 숫자의 순서는
유지해야 합니다)
만약 5276823 이 주어지고 3개의 자릿수를 제거한다면
7823이 가장 큰 숫자가 됩니다.
입력
첫째 줄에 숫자(길이는 1000을 넘지 않습니다)와 제가해야할 자릿수의 개수가 주어집니다.
출력
가장 큰 수를 출력합니다.
입력예제 
5276823 3
출력예제
7823
입력예제 
9977252641 5
출력예제 
99776
'''
def max():
    n,m=input("구하고 싶은 수, 뺄 자리수 : ").split()